<!--
@license https://github.com/t2ym/my-seed-element/blob/master/LICENSE.md
Copyright (c) 2016, Tetsuya Mori <t2y3141592@gmail.com>. All rights reserved.
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <link rel="import" href="../my-seed-element.html">
    <link rel="import" href="bound-my-seed-element.html">
  </head>
  <body>

    <test-fixture id="default">
      <template>
        <my-seed-element></my-seed-element>
      </template>
    </test-fixture>

    <test-fixture id="static">
      <template>
        <my-seed-element lang="en" options="{}" offset="1">123456.789</my-seed-element>
      </template>
    </test-fixture>

    <test-fixture id="bound">
      <template is="dom-template" id="bound-template">
        <my-seed-element lang="en" options="{}" offset="1">{{number}}</my-seed-element>
      </template>
    </test-fixture>

    <test-fixture id="bound-default-options">
      <template is="dom-template" id="bound-template">
        <my-seed-element lang="en" offset="1">{{number}}</my-seed-element>
      </template>
    </test-fixture>

    <test-fixture id="bound-currency-options">
      <template is="dom-template" id="bound-template">
        <my-seed-element lang="en" options='{ "style": "currency", "currency": "USD" }' offset="1">{{number}}</my-seed-element>
      </template>
    </test-fixture>

    <test-fixture id="bound-and-wrapped">
      <template>
        <bound-my-seed-element></bound-my-seed-element>
      </template>
    </test-fixture>

    <script>
suite('<my-seed-element>', function () {

  suite('default values', function () {
    var el;

    setup(function () {
      el = fixture('default');
    });

    test('default lang property', function () {
      assert.equal(el.lang, 'en', 'default lang is en');
    });

    test('default options property', function () {
      assert.isUndefined(el.options, 'default options is undefined');
    });

    test('default raw property', function () {
      assert.equal(el.raw, '', 'default raw is a null string');
    });

    test('default offset property', function () {
      assert.isNumber(el.offset, 'offset is a number');
      assert.equal(el.offset, 0, 'default offset is 0');
    });

    test('default rawNumber property', function () {
      assert.isUndefined(el.rawNumber, 'rawNumber is undefined when raw is null');
    });

    test('default number property', function () {
      assert.isUndefined(el.number, 'number is undefined when raw is null');
    });

    test('default formatted property', function () {
      assert.isUndefined(el.formatted, 'formatted is undefined when raw is null');
    });
  });

  if (!Number.isNaN) {
    // polyfill Number.isNaN for IE11
    Number.isNaN = function (value) {
      return typeof value === 'number' && isNaN(value);
    };
  }
  var rawValue1 = '123456.789';
  var rawNumber1 = Number(rawValue1);
  var rawValueInvalid = 'ABC';
  var rawNumberInvalid = Number(rawValueInvalid);
  var offset1 = 1;
  var offset2 = 2;
  var offsetInvalid = 'ABCD';
  var number1 = rawNumber1 - offset1;
  var number2 = rawNumber1 - offset2;
  var formatted1_en = '123,455.789';
  var formatted1_fr = '123\u00A0455,789';
  var formatted1_USD = '$123,455.79';
  var formatted1_JPY = '짜123,456';
  var formatted1_offset = '123,454.789';
  var suites = [
    { 
      suite: 'static value', 
      fixture: 'static', 
      model: undefined, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: {},
      formatted: formatted1_en
    },
    { 
      suite: 'bound value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: {},
      formatted: formatted1_en
    },
    { 
      suite: 'change raw value', 
      fixture: 'bound', 
      model: { number: '987654.321' }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: {},
      assign: { raw: rawValue1 },
      formatted: formatted1_en
    },
    { 
      suite: 'change lang value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: {},
      assign: { lang: 'fr' },
      formatted: formatted1_fr
    },
    { 
      suite: 'change options object value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: { 'style': 'currency', 'currency': 'USD' },
      assign: { options: { 'style': 'currency', 'currency': 'USD' } },
      formatted: formatted1_USD
    },
    { 
      suite: 'change options property values', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: { 'style': 'currency', 'currency': 'USD' },
      assign: { 'options': {}, 'options.style': 'currency', 'options.currency': 'USD' },
      formatted: formatted1_USD
    },
    { 
      suite: 'change currency options object value', 
      fixture: 'bound-currency-options', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: { 'style': 'currency', 'currency': 'JPY' },
      assign: { options: { 'style': 'currency', 'currency': 'JPY' } },
      formatted: formatted1_JPY
    },
    { 
      suite: 'change currency options property values', 
      fixture: 'bound-currency-options', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: { 'style': 'currency', 'currency': 'JPY' },
      assign: { 'options.currency': 'JPY' },
      formatted: formatted1_JPY
    },
    { 
      suite: 'default options object value', 
      fixture: 'bound-default-options', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: undefined,
      formatted: formatted1_en
    },
    { 
      suite: 'change options object value from default options', 
      fixture: 'bound-default-options', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: { 'style': 'currency', 'currency': 'USD' },
      assign: { options: { 'style': 'currency', 'currency': 'USD' } },
      formatted: formatted1_USD
    },
    { 
      suite: 'change options property values from default options', 
      fixture: 'bound-default-options', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset1,
      rawNumber: rawNumber1,
      number: number1,
      options: { 'style': 'currency', 'currency': 'USD' },
      assign: { 'options': {}, 'options.style': 'currency', 'options.currency': 'USD' },
      formatted: formatted1_USD
    },
    { 
      suite: 'change offset value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offset2,
      rawNumber: rawNumber1,
      number: number2,
      options: {},
      assign: { offset: offset2 },
      formatted: formatted1_offset
    },
    { 
      suite: 'invalid value', 
      fixture: 'bound', 
      model: { number: rawValueInvalid }, 
      rawValue: rawValueInvalid,
      offset: offset1,
      rawNumber: NaN,
      number: NaN,
      options: {},
      formatted: 'NaN'
    },
    { 
      suite: 'invalid offset value', 
      fixture: 'bound', 
      model: { number: rawValue1 }, 
      rawValue: rawValue1,
      offset: offsetInvalid,
      rawNumber: rawValue1,
      number: NaN,
      options: {},
      assign: { offset: offsetInvalid },
      formatted: 'NaN'
    }
  ];

  suites.forEach(function (params) {

    suite(params.suite, function () {
      var el;
      var rawValue = params.rawValue;
      var fixtureElement;
      var lang = params.assign && params.assign.lang ? params.assign.lang : 'en';
      var updateModel = function (element, model) {
        for (var name in model) {
          var path = name.split(/[.]/);
          if (path.length === 1) {
            element[name] = model[name];
          }
          else {
            var cursor = element;
            var p = path.shift();
            while (p) {
              if (path.length < 1) {
                cursor[p] = model[name];
                element.notifyPath(name, model[name], true);
                break;
              }
              else {
                cursor = cursor[p];
              }
              p = path.shift();
            }
          }
        }
      };

      setup(function () {
        el = fixture(params.fixture, params.model);
      });

      test('lang property from attribute', function () {
        updateModel(el, params.assign);
        assert.equal(el.lang, lang, 'lang is set');
      });

      test('options property from attribute is set as ' 
          + JSON.stringify(params.options), function () {
        updateModel(el, params.assign);
        assert.deepEqual(el.options, params.options, 'options is set');
      });

      test('textContent is set as ' + rawValue, function () {
        updateModel(el, params.assign);
        assert.equal(Polymer.dom(el).textContent, rawValue, 'textContent is ' + rawValue);
      });

      test('raw property is set as ' + rawValue, function () {
        updateModel(el, params.assign);
        assert.isString(el.raw, 'raw property is a string');
        assert.equal(el.raw, rawValue, 'raw property is set as the raw value');
      });

      test('offset property from attribute is set as ' + params.offset, function () {
        updateModel(el, params.assign);
        if (typeof params.offset === 'number') {
          assert.isNumber(el.offset, 'offset is a number');
        }
        if (Number.isNaN(params.offset)) {
          assert.ok(Number.isNaN(el.offset), 'offset is NaN');
        }
        else {
          assert.equal(el.offset, params.offset, 'offset is ' + params.offset);
        }
      });

      test('rawNumber property is set as ' + params.rawNumber, function () {
        updateModel(el, params.assign);
        assert.isNumber(el.rawNumber, 'rawNumber is a number');
        if (Number.isNaN(params.rawNumber)) {
          assert.ok(Number.isNaN(el.rawNumber), 'rawNumber is NaN');
        }
        else {
          assert.equal(el.rawNumber, params.rawNumber, 'rawNumber is set');
        }
      });

      test('number property is set as ' + params.number, function () {
        updateModel(el, params.assign);
        assert.isNumber(el.number, 'number is a number');
        if (Number.isNaN(params.number)) {
          assert.ok(Number.isNaN(el.number), 'number is NaN');
        }
        else {
          assert.equal(el.number, params.number, 'number is set');
        }
      });

      test('formatted property is set as ' + params.formatted, function () {
        updateModel(el, params.assign);
        assert.isString(el.formatted, 'formatted is a string');
        assert.equal(el.formatted, params.formatted);
      });

      test('renders the formatted number ' + params.formatted, function () {
        updateModel(el, params.assign);
        assert.equal(el.$.number.textContent, params.formatted);
      });

    });
  });

  suite('bound in a local DOM', function () {
    var wrapper;
    var el;

    var reattach = function (placeholder) {
      var num = Polymer.dom(placeholder).querySelector('#num');
      var empty = Polymer.dom(placeholder).querySelector('#empty');
      Polymer.dom(placeholder).removeChild(num);
      Polymer.dom(placeholder).removeChild(empty);
      Polymer.dom(placeholder).appendChild(num);
      Polymer.dom(placeholder).appendChild(empty);
    };

    var updateModel = function (element, model) {
      for (var name in model) {
        var path = name.split(/[.]/);
        if (path.length === 1) {
          element[name] = model[name];
        }
        else {
          var cursor = element;
          var p = path.shift();
          while (p) {
            if (path.length < 1) {
              cursor[p] = model[name];
              element.notifyPath(name, model[name], true);
              break;
            }
            else {
              cursor = cursor[p];
            }
            p = path.shift();
          }
        }
      }
    };

    [ false, true ].forEach(function (isReattach) {

      setup(function () {
        wrapper = fixture('bound-and-wrapped');
        if (isReattach) {
          reattach(wrapper.$.placeholder);
        }
      });

      suite('bound and wrapped' + (isReattach ? ' with reattaching' : ''), function () {
        setup(function () {
          el = wrapper.$.num;
        });

        test('default lang property is en', function () {
          assert.equal(el.lang, 'en', 'default lang is en');
        });

        test('default options property is undefined', function () {
          assert.isUndefined(el.options, 'default options is undefined');
        });

        test('empty raw property', function () {
          assert.isString(el.raw, 'empty raw is a string');
          assert.equal(el.raw, '', 'empty raw is a null string');
        });

        test('default offset property is 0', function () {
          assert.isNumber(el.offset, 'offset is a number');
          assert.equal(el.offset, 0, 'default offset is 0');
        });

        test('default rawNumber property is undefined', function () {
          assert.isUndefined(el.rawNumber, 'rawNumber is undefined when raw is null');
        });

        test('default number property is undefined', function () {
          assert.isUndefined(el.number, 'number is undefined when raw is null');
        });

        test('default formatted property is undefined', function () {
          assert.isUndefined(el.formatted, 'formatted is undefined when raw is null');
        });

        test('renders a null string', function () {
          assert.equal(el.$.number.textContent, '', 'textContent is empty');
        });
      });

      suite('bound value changed' 
            + (isReattach ? ' with reattaching' : ''), function () {
        setup(function () {
          el = wrapper.$.num;
        });

        test('change bound value to ' + rawNumber1, function (done) {
          el.addEventListener('rendered', function (e) {
            assert.equal(el.$.number.textContent, '123,456.789', 
                        'renders the formatted number');    
            done();
          });
          wrapper.number = rawNumber1;
        });

      });

      suite('bound value emptied' 
            + (isReattach ? ' with reattaching' : ''), function () {
        setup(function () {
          el = wrapper.$.num2;
        });

        test('change bound value to empty', function (done) {
          el.addEventListener('rendered', function (e) {
            assert.equal(el.$.number.textContent, '', 
                        'renders the formatted number');    
            done();
          });
          wrapper.number2 = '';
        });

      });

      suite('non-bound empty textContent changed' 
            + (isReattach ? ' with reattaching' : ''), function () {
        setup(function () {
          el = wrapper.$.empty;
        });

        test('change empty textContent value to ' + rawNumber1, function (done) {
          el.addEventListener('rendered', function (e) {
            assert.equal(el.$.number.textContent, '123,456.789', 
                        'renders the formatted number');    
            done();
          });
          Polymer.dom(el).textContent = rawNumber1;
        });

      });

      suite('currency options value changed' 
            + (isReattach ? ' with reattaching' : ''), function () {
        setup(function () {
          el = wrapper.$.currency;
        });

        test('change currency options value to JPY', function (done) {
          el.addEventListener('rendered', function (e) {
            assert.equal(el.$.number.textContent, '짜123,457', 
                        'renders the formatted currency');
            done();
          });
          wrapper.options.currency = 'JPY';
          wrapper.notifyPath('options.currency', wrapper.options.currency, true);
        });

      });

      suite('currency options value changed' 
            + (isReattach ? ' with reattaching' : ''), function () {
        setup(function () {
          el = wrapper.$.currency;
        });

        test('change currency options value to JPY and render()', function (done) {
          el.addEventListener('rendered', function (e) {
            assert.equal(el.$.number.textContent, '짜123,457', 
                        'renders the formatted currency');
            done();
          });
          wrapper.options.currency = 'JPY';
          el.render();
        });

      });

      suite('bound currency options value changed' 
            + (isReattach ? ' with reattaching' : ''), function () {
        setup(function () {
          el = wrapper.$.currency;
        });

        test('change bound currency options value to JPY', function (done) {
          el.addEventListener('rendered', function (e) {
            assert.equal(el.$.number.textContent, '짜123,457', 
                        'renders the formatted currency');
            done();
          });
          wrapper.$.currencySelector.select('JPY');
          //wrapper.notifyPath('options.currency', wrapper.options.currency, true);
        });

      });
    });    
  });

});
    </script>

  </body>
</html>
